/* This file is autogenerated by scripts/decodetree.py.  */

typedef struct {
    int l;
    int op;
    int rn;
} arg_disas_m_nocp1;

typedef struct {
    int imm;
    int size;
    int vd;
} arg_disas_m_nocp2;

typedef struct {
    int cp;
} arg_nocp;

typedef arg_disas_m_nocp1 arg_VLLDM_VLSTM;
static bool trans_VLLDM_VLSTM(DisasContext *ctx, arg_VLLDM_VLSTM *a);
typedef arg_disas_m_nocp2 arg_VSCCLRM;
static bool trans_VSCCLRM(DisasContext *ctx, arg_VSCCLRM *a);
typedef arg_nocp arg_NOCP;
static bool trans_NOCP(DisasContext *ctx, arg_NOCP *a);
typedef arg_nocp arg_NOCP_8_1;
static bool trans_NOCP_8_1(DisasContext *ctx, arg_NOCP_8_1 *a);

static void disas_m_nocp_extract_disas_m_nocp_Fmt_0(DisasContext *ctx, arg_disas_m_nocp1 *a, uint32_t insn)
{
    a->l = extract32(insn, 20, 1);
    a->rn = extract32(insn, 16, 4);
    a->op = extract32(insn, 7, 1);
}

static void disas_m_nocp_extract_disas_m_nocp_Fmt_1(DisasContext *ctx, arg_disas_m_nocp2 *a, uint32_t insn)
{
    a->imm = extract32(insn, 1, 7);
    a->vd = deposit32(extract32(insn, 12, 4), 4, 28, extract32(insn, 22, 1));
    a->size = 3;
}

static void disas_m_nocp_extract_disas_m_nocp_Fmt_2(DisasContext *ctx, arg_disas_m_nocp2 *a, uint32_t insn)
{
    a->imm = extract32(insn, 0, 8);
    a->vd = deposit32(extract32(insn, 22, 1), 1, 31, extract32(insn, 12, 4));
    a->size = 2;
}

static void disas_m_nocp_extract_disas_m_nocp_Fmt_3(DisasContext *ctx, arg_nocp *a, uint32_t insn)
{
    a->cp = extract32(insn, 8, 4);
}

static void disas_m_nocp_extract_disas_m_nocp_Fmt_4(DisasContext *ctx, arg_nocp *a, uint32_t insn)
{
    a->cp = 10;
}

static bool disas_m_nocp(DisasContext *ctx, uint32_t insn)
{
    union {
        arg_disas_m_nocp1 f_disas_m_nocp1;
        arg_disas_m_nocp2 f_disas_m_nocp2;
        arg_nocp f_nocp;
    } u;

    switch (insn & 0xec000000) {
    case 0xec000000:
        /* 111.11.. ........ ........ ........ */
        if ((insn & 0x13e0ff7f) == 0x00200a00) {
            /* 11101100 001..... 00001010 .0000000 */
            /* ../target/arm/m-nocp.decode:39 */
            disas_m_nocp_extract_disas_m_nocp_Fmt_0(ctx, &u.f_disas_m_nocp1, insn);
            if (trans_VLLDM_VLSTM(ctx, &u.f_disas_m_nocp1)) return true;
        }
        if ((insn & 0x13bf0f01) == 0x009f0b00) {
            /* 11101100 1.011111 ....1011 .......0 */
            /* ../target/arm/m-nocp.decode:41 */
            disas_m_nocp_extract_disas_m_nocp_Fmt_1(ctx, &u.f_disas_m_nocp2, insn);
            if (trans_VSCCLRM(ctx, &u.f_disas_m_nocp2)) return true;
        }
        if ((insn & 0x13bf0f00) == 0x009f0a00) {
            /* 11101100 1.011111 ....1010 ........ */
            /* ../target/arm/m-nocp.decode:42 */
            disas_m_nocp_extract_disas_m_nocp_Fmt_2(ctx, &u.f_disas_m_nocp2, insn);
            if (trans_VSCCLRM(ctx, &u.f_disas_m_nocp2)) return true;
        }
        if ((insn & 0x03000000) == 0x02000000) {
            /* 111.1110 ........ ........ ........ */
            /* ../target/arm/m-nocp.decode:44 */
            disas_m_nocp_extract_disas_m_nocp_Fmt_3(ctx, &u.f_nocp, insn);
            if (trans_NOCP(ctx, &u.f_nocp)) return true;
        }
        if ((insn & 0x02000000) == 0x00000000) {
            /* 111.110. ........ ........ ........ */
            /* ../target/arm/m-nocp.decode:45 */
            disas_m_nocp_extract_disas_m_nocp_Fmt_3(ctx, &u.f_nocp, insn);
            if (trans_NOCP(ctx, &u.f_nocp)) return true;
        }
        if ((insn & 0x03000000) == 0x03000000) {
            /* 111.1111 ........ ........ ........ */
            /* ../target/arm/m-nocp.decode:47 */
            disas_m_nocp_extract_disas_m_nocp_Fmt_4(ctx, &u.f_nocp, insn);
            if (trans_NOCP_8_1(ctx, &u.f_nocp)) return true;
        }
        break;
    }
    return false;
}
